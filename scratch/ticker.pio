.program ticker
; the code must be loaded at address 0, because it uses computed jumps
.origin 0

; this code monitors a pin and continuously updates a ticker counter
; when the pin changes state, it outputs the tic value
; tics once per six clock cycles

    JMP sample          ; 0b00 (0) previous 0 current 0
    JMP update side 1   ; 0b01 (1) previous 0 current 1
    JMP update side 0   ; 0b10 (2) previous 1 current 0
    JMP sample          ; 0b11 (3) previous 1 current 1

update:
    jmp y--, continue_update [3] ;  added 3 cycles to update entry to match sample entry cycles
continue_update:
    MOV ISR, ~Y  ; y is always decremented, so use the negate
    PUSH noblock ; push contents of ISR to RX FIFO (clears ISR) for DMA to transfer, don't wait

sample:
    jmp y--, continue_sample 
continue_sample:
    OUT ISR, 1    ; shift previous state of input pin stored in OSR to ISR 
    IN PINS, 1    ; shift in current state of input pin into ISR next to previous state of input pin    
    MOV OSR, ISR  ; copy the ISR to OSR so that we can get the current value next time
    MOV PC, ISR   ; jump to the computed address
